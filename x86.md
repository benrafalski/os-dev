# x86 OS Development

## Boot Sequence

### POST

- Power-On Self-Test: runs when computer is turned on
- Finds a floppy disk, cdrom, or hard disk to boot from

### Master Boot Record

- Boot sector: 512 bytes on a storage device that the BIOS loads and runs to boot
- MBR is the boot sector of a hard disk
- Magic number: BIOS looks for 0x55 0xAA at the end of the boot sector
- After the BIOS finds the boot sector, it loads it to 0x0000:0x7c000 (segment 0, address 0x7c00)

### Real Mode

- After the boot sector is ran, the CPU will be in 16-bit Real Mode
- All processors start in Real Mode for backwards compatability
- Real Mode: 1MB RAM, not memory protection (GDT), no virtial memory, no security, 16-bits only, addressing more than 64KB requires segment registers, can use BIOS functions/interrupts
- 32 bit registers are still accessible
- High memory area: if ds=0xFFFF and an offset=0x10 to 0xFFFF you can access physical memory from 0x100000 to 0x10FFEF

### Protected Mode

- From Real Mode you can then switch to 32-bit Protected Mode
- 4GB RAM, virtual addressing, memory and IO protections, restrict instructions using rings
- BIOS interrupts can no longer be used since they are 16-bit

#### GDT

- Global descriptor table
- Contains entries telling the CPU about memory segments
- pointed to by value in `gdtr` register, loaded using `lgdt` instruction
- Table entries are 8 bytes long
- First entry should be null
- Table entries are accessed by segment selectors that are loaded in to segmentation registers
  - segment selector is a 16-bit data structure
  - | 15 - 3 | 2   | 1 - 0 |
    | ------ | --- | ----- |
    | Index  | TI  | RPL   |
  - TI: (0) for GDT, (1) for LDT
  - RPL: requested privilege level (Ring 0-3)
- Segment Descriptor:
  <table>
  <tr>
  <td>63 56</td>
  <td>55 52</td>
  <td>51 48</td>
  <td>47 40</td>
  <td>39 32</td>
  </tr>
  <tr>
  <td>Base</td>
  <td>Flags</td>
  <td>Limit</td>
  <td>Access Byte</td>
  <td>Base</td>
  </tr>
  <tr>
  <td>31 16</td>
  <td>15 0</td>
  </tr>
  <tr>
  <td>Base</td>
  <td>Limit</td>
  </tr>
  </table>

  - Base: Linear adddress where segment begins
  - Limit: Maximum addressable unit (e.g. 0xFFFFF is 4GB)
  - Access Byte: https://wiki.osdev.org/Global_Descriptor_Table
  - Flags:
  -

#### Switching to Protected Mode

```assembly
[bits 16]
cli            ; 1. disable interrupts
lgdt [gdtr]    ; 2. load GDT register with start address of Global Descriptor Table
mov eax, cr0
or al, 1       ; 3. set PE (Protection Enable) bit in CR0 (Control Register 0)
mov cr0, eax

; 4. Perform far jump to selector 0x08 (offset into GDT, pointing at a 32bit PM code segment descriptor to load CS with proper PM32 descriptor)
jmp 0x08:PModeMain

[bits 32]
PModeMain:
; load DS, ES, FS, GS, SS, ESP ...
```

## Interrupts

### Interrupt Serivce Routines

[ISRs](https://wiki.osdev.org/Interrupt_Service_Routines)

### Interrupt Descriptor Table

- data structure in protected/long mode, replaces real mode interrupt vector table (IVT)
- tells the CPU where the interrupt serivce routines (ISR) are located
- pointed to by value in `idtr` register, loaded using `lidt` instruction
- there are 256 entries, one for each interrupt. If the IDT has less, then a General Protection Fault occurs.
- the IDT entries are 16 bytes long and have an address and content at that address
- Gate Descriptor structure:
  <table>
  <tr>
  <td>127 96</td>
  </tr>
  <tr>
  <td>Reserved</td>
  </tr>
  <tr>
  <td>95 64</td>
  </tr>
  <tr>
  <td>Offset</td>
  </tr>
  <tr>
  <td>63 48</td>
  <td>47</td>
  <td>46 45</td>
  <td>44</td>
  <td>43 40</td>
  <td>39 35</td>
  <td>34 32</td>
  </tr>
  <tr>
  <td>Offset</td>
  <td>P</td>
  <td>DPL</td>
  <td>0</td>
  <td>Gate Type</td>
  <td>Reserved</td>
  <td>IST</td>
  </tr>
  <tr>
  <td>31 16</td>
  <td>15 0</td>
  </tr>
  <tr>
  <td>Segment Selector</td>
  <td>Offset</td>
  </tr>
  </table>
  
  - Offset: split into three parts, address of the entry point of the ISR
  - Selector: segment selector which must point to a valid code in the GDT
  - IST: Offset into the Interrupt Stack Table stored in the Task State Segment, not used if all bits set to 0
  - Gate Type: 0xE for interrupt gates (specifies an ISR, save address of <i>next</i> instruction), 0xF for trap gates (used to handle an exception, save address of <i>current</i> instruction)
  - DPL: CPU privilege levels that are allowed to access this interrupt via the `int` instruction
  - P: present bit, must be 1 for the descriptor to be valid

  ```c
  struct InterruptDescriptor64 {
      uint16_t offset_1;        // offset bits 0..15
      uint16_t selector;        // a code segment selector in GDT or LDT
      uint8_t  ist;             // bits 0..2 holds Interrupt Stack Table offset, rest of bits zero.
      uint8_t  type_attributes; // gate type, dpl, and p fields, for interrupt gate do 0x8E, for trap gate do 0x8F
      uint16_t offset_2;        // offset bits 16..31
      uint32_t offset_3;        // offset bits 32..63
      uint32_t zero;            // reserved
      };
  ```

## BIOS

https://wiki.osdev.org/BIOS

## Memory

https://wiki.osdev.org/Memory_Map_(x86)
https://wiki.osdev.org/Detecting_Memory_(x86)

### Segmentation

- Registers: `cs`, `ds`, `es`, `fs`, `gs`, `ss`
- `segment`:`offset`
- `PhysicalAddress = Segment * 16 + Offset`
- Example: 0x12f3:0x4b27 -> `PhysicalAddress` = 0x17a57
  https://wiki.osdev.org/Segmentation

### The Stack

- Registers: ss (segment) and sp (top of stack)
- Instructions: used for `push`, `pop`, `call`, `int`, and `ret`


## Instructions
### CPUID
- can be used to get info about the CPU like the vendor string, model number, size of caches, and the list of CPU features supported
- In Linux use: ```lscpu``` or ```cat /proc/cpuinfo```
- In GCC use: cpuid.h
  ```c
  #include <cpuid.h>
  
  /* Example: Get CPU's model number */
  static int get_model(void)
  {
      int ebx, unused;
      __cpuid(0, unused, ebx, unused, unused);
      return ebx;
  }
  
  /* Example: Check for builtin local APIC. */
  static int check_apic(void)
  {
      unsigned int eax, unused, edx;
      __get_cpuid(1, &eax, &unused, &unused, %edx);
      return edx & CPUID_FEAT_EDX_APIC;
  }
  ```
- Basic usage: you can call it with different values in ```eax``` and it will return different info about the CPU
- Vendor string: set ```eax = 0``` and ```cpuid``` returns vendor ID string in ```ebx```, ```edx```, and ```ecx```. Intel should return "GenuineIntel"
- CPU Features: set eax = 1 and cpuid returns a bit field in edx (newer processors in ecx). 
  ```c
  enum {
      CPUID_FEAT_ECX_SSE3         = 1 << 0, 
      CPUID_FEAT_ECX_PCLMUL       = 1 << 1,
      CPUID_FEAT_ECX_DTES64       = 1 << 2,
      CPUID_FEAT_ECX_MONITOR      = 1 << 3,  
      CPUID_FEAT_ECX_DS_CPL       = 1 << 4,  
      CPUID_FEAT_ECX_VMX          = 1 << 5,  
      CPUID_FEAT_ECX_SMX          = 1 << 6,  
      CPUID_FEAT_ECX_EST          = 1 << 7,  
      CPUID_FEAT_ECX_TM2          = 1 << 8,  
      CPUID_FEAT_ECX_SSSE3        = 1 << 9,  
      CPUID_FEAT_ECX_CID          = 1 << 10,
      CPUID_FEAT_ECX_SDBG         = 1 << 11,
      CPUID_FEAT_ECX_FMA          = 1 << 12,
      CPUID_FEAT_ECX_CX16         = 1 << 13, 
      CPUID_FEAT_ECX_XTPR         = 1 << 14, 
      CPUID_FEAT_ECX_PDCM         = 1 << 15, 
      CPUID_FEAT_ECX_PCID         = 1 << 17, 
      CPUID_FEAT_ECX_DCA          = 1 << 18, 
      CPUID_FEAT_ECX_SSE4_1       = 1 << 19, 
      CPUID_FEAT_ECX_SSE4_2       = 1 << 20, 
      CPUID_FEAT_ECX_X2APIC       = 1 << 21, 
      CPUID_FEAT_ECX_MOVBE        = 1 << 22, 
      CPUID_FEAT_ECX_POPCNT       = 1 << 23, 
      CPUID_FEAT_ECX_TSC          = 1 << 24, 
      CPUID_FEAT_ECX_AES          = 1 << 25, 
      CPUID_FEAT_ECX_XSAVE        = 1 << 26, 
      CPUID_FEAT_ECX_OSXSAVE      = 1 << 27, 
      CPUID_FEAT_ECX_AVX          = 1 << 28,
      CPUID_FEAT_ECX_F16C         = 1 << 29,
      CPUID_FEAT_ECX_RDRAND       = 1 << 30,
      CPUID_FEAT_ECX_HYPERVISOR   = 1 << 31,
  
      CPUID_FEAT_EDX_FPU          = 1 << 0,  
      CPUID_FEAT_EDX_VME          = 1 << 1,  
      CPUID_FEAT_EDX_DE           = 1 << 2,  
      CPUID_FEAT_EDX_PSE          = 1 << 3,  
      CPUID_FEAT_EDX_TSC          = 1 << 4,  
      CPUID_FEAT_EDX_MSR          = 1 << 5,  
      CPUID_FEAT_EDX_PAE          = 1 << 6,  
      CPUID_FEAT_EDX_MCE          = 1 << 7,  
      CPUID_FEAT_EDX_CX8          = 1 << 8,  
      CPUID_FEAT_EDX_APIC         = 1 << 9,  
      CPUID_FEAT_EDX_SEP          = 1 << 11, 
      CPUID_FEAT_EDX_MTRR         = 1 << 12, 
      CPUID_FEAT_EDX_PGE          = 1 << 13, 
      CPUID_FEAT_EDX_MCA          = 1 << 14, 
      CPUID_FEAT_EDX_CMOV         = 1 << 15, 
      CPUID_FEAT_EDX_PAT          = 1 << 16, 
      CPUID_FEAT_EDX_PSE36        = 1 << 17, 
      CPUID_FEAT_EDX_PSN          = 1 << 18, 
      CPUID_FEAT_EDX_CLFLUSH      = 1 << 19, 
      CPUID_FEAT_EDX_DS           = 1 << 21, 
      CPUID_FEAT_EDX_ACPI         = 1 << 22, 
      CPUID_FEAT_EDX_MMX          = 1 << 23, 
      CPUID_FEAT_EDX_FXSR         = 1 << 24, 
      CPUID_FEAT_EDX_SSE          = 1 << 25, 
      CPUID_FEAT_EDX_SSE2         = 1 << 26, 
      CPUID_FEAT_EDX_SS           = 1 << 27, 
      CPUID_FEAT_EDX_HTT          = 1 << 28, 
      CPUID_FEAT_EDX_TM           = 1 << 29, 
      CPUID_FEAT_EDX_IA64         = 1 << 30,
      CPUID_FEAT_EDX_PBE          = 1 << 31
  };
  ```
#### Check if CPUID is supported
```assembly
pushfd                               ;Save EFLAGS
pushfd                               ;Store EFLAGS
xor dword [esp],0x00200000           ;Invert the ID bit in stored EFLAGS
popfd                                ;Load stored EFLAGS (with ID bit inverted)
pushfd                               ;Store EFLAGS again (ID bit may or may not be inverted)
pop eax                              ;eax = modified EFLAGS (ID bit may or may not be inverted)
xor eax,[esp]                        ;eax = whichever bits were changed
popfd                                ;Restore original EFLAGS
and eax,0x00200000                   ;eax = zero if ID bit can't be changed, else non-zero
ret
```

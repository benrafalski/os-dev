# x86 OS Development

## Boot Sequence
### POST
- Power-On Self-Test: runs when computer is turned on
- Finds a floppy disk, cdrom, or hard disk to boot from

### Master Boot Record
- Boot sector: 512 bytes on a storage device that the BIOS loads and runs to boot
- MBR is the boot sector of a hard disk
- Magic number: BIOS looks for 0x55 0xAA at the end of the boot sector
- After the BIOS finds the boot sector, it loads it to 0x0000:0x7c000 (segment 0, address 0x7c00)

### Real Mode
- After the boot sector is ran, the CPU will be in 16-bit Real Mode
- All processors start in Real Mode for backwards compatability
- Real Mode: 1MB RAM, not memory protection (GDT), no virtial memory, no security, 16-bits only, addressing more than 64KB requires segment registers, can use BIOS functions/interrupts
- 32 bit registers are still accessible
- High memory area: if ds=0xFFFF and an offset=0x10 to 0xFFFF you can access physical memory from 0x100000 to 0x10FFEF

### Protected Mode
- From Real Mode you can then switch to 32-bit Protected Mode
- 4GB RAM, virtual addressing, memory and IO protections, restrict instructions using rings
- BIOS interrupts can no longer be used since they are 16-bit
#### GDT
- Global descriptor table
- Contains entries telling the CPU about memory segments
- pointed to by value in ```gdtr``` register, loaded using ```lgdt``` instruction
- Table entries are 8 bytes long
- First entry should be null
- Table entries are accessed by segment selectors that are loaded in to segmentation registers
    - segment selector is a 16-bit data structure
    - | 15 - 3 | 2 | 1 - 0 |
        | -------- | ------- | ------- |
        | Index  | TI | RPL |
    - TI: (0) for GDT, (1) for LDT
    - RPL: requested privilege level (Ring 0-3) 
- Segment Descriptor:
        <table>
            <tr>
                <td>63  56</td>
                <td>55  52</td>
                <td>51  48</td>
                <td>47  40</td>
                <td>39  32</td>
            </tr>
            <tr>
                <td>Base</td>
                <td>Flags</td>
                <td>Limit</td>
                <td>Access Byte</td>
                <td>Base</td> 
            </tr>
            <tr>
                <td>31  16</td>
                <td>15  0</td>
            </tr>
            <tr>
                <td>Base</td>
                <td>Limit</td>
            </tr>
        </table>
    - Base: Linear adddress where segment begins
    - Limit: Maximum addressable unit (e.g. 0xFFFFF is 4GB)
    - Access Byte: https://wiki.osdev.org/Global_Descriptor_Table
    - Flags:
    - 


#### Switching to Protected Mode
```assembly
[bits 16]
cli            ; 1. disable interrupts
lgdt [gdtr]    ; 2. load GDT register with start address of Global Descriptor Table
mov eax, cr0 
or al, 1       ; 3. set PE (Protection Enable) bit in CR0 (Control Register 0)
mov cr0, eax
 
; 4. Perform far jump to selector 0x08 (offset into GDT, pointing at a 32bit PM code segment descriptor to load CS with proper PM32 descriptor)
jmp 0x08:PModeMain

[bits 32]
PModeMain:
; load DS, ES, FS, GS, SS, ESP ...
```

### 


## BIOS
https://wiki.osdev.org/BIOS


## Memory
https://wiki.osdev.org/Memory_Map_(x86)
https://wiki.osdev.org/Detecting_Memory_(x86)
### Segmentation
- Registers: ```cs```, ```ds```, ```es```, ```fs```, ```gs```, ```ss```
- ```segment```:```offset```
- ```PhysicalAddress = Segment * 16 + Offset```
- Example: 0x12f3:0x4b27 -> ```PhysicalAddress``` = 0x17a57
https://wiki.osdev.org/Segmentation
### The Stack
- Registers: ss (segment) and sp (top of stack)
- Instructions: used for ```push```, ```pop```, ```call```, ```int```, and ```ret```